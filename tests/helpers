#!/usr/bin/env bash
set -ae

function finish {
  set +ex
}
trap finish EXIT

function fatal {
  >&2 echo "$1"
  exit 1
}

function get_container_name {
  # Removes any non-alphanumeric or '_' characters,
  # in an attempt to match docker-compose service naming convention
  echo "${BATS_IMAGE//[^[:alnum:]_]/}_app_1"
}

function begin_output {
  ARTIFACT_LOGS_DIR=${ARTIFACT_LOGS_DIR:-"/tmp/artifacts/logs"}
  [[ -d "$ARTIFACT_LOGS_DIR" ]] || mkdir -p $ARTIFACT_LOGS_DIR
  [[ -f "${ARTIFACT_LOGS_DIR}/${BATS_IMAGE}" ]] || touch "${ARTIFACT_LOGS_DIR}/${BATS_IMAGE}"

  PS4='+($(basename $BASH_SOURCE):${LINENO}): ${FUNCNAME[0]:+${FUNCNAME[0]}(): }'
  echo -e "=============== vvv [${BATS_TEST_NUMBER}] ${BATS_IMAGE} - ${BATS_TEST_DESCRIPTION}" >> "${ARTIFACT_LOGS_DIR}/${BATS_IMAGE}"
}

function store_output {
  local string
  # $output is defined in bats `run` command, don't panic @shellcheck
  # shellcheck disable=SC2154
  string=$(echo "${output}" | sed -e "s/\x1B\[([0-9]{1,2}(;[0-9]{1,2})?)?[mGK]//g")
  echo "$string" >> "${ARTIFACT_LOGS_DIR}/${BATS_IMAGE}"
  echo -e "=============== ^^^ [${BATS_TEST_NUMBER}] ${BATS_IMAGE} - ${BATS_TEST_DESCRIPTION}\n" >> "${ARTIFACT_LOGS_DIR}/${BATS_IMAGE}"
  PS4=''
}

function curl_check_response_regex {
  set -ex
  trap finish EXIT
  local endpoint=${1:-"http://localhost:80"}
  local container=${2:-$(get_container_name)}
  local regex=${3:-"OK"}

  if [[ $CIRCLECI ]]
  then
    # See: https://circleci.com/docs/2.0/docker-compose/
    docker run --network "container:${container}" appropriate/curl -s -k "${endpoint}" | grep "${regex}"
  else
    curl -s -k "${endpoint}" | grep "${regex}"
  fi
}

function curl_check_status_code {
  set -ex
  trap finish EXIT
  local endpoint=${1:-"http://localhost:80"}
  local container=${2:-$(get_container_name)}
  local status_code=${3:-200}

  if [[ $CIRCLECI ]]
  then
    # See: https://circleci.com/docs/2.0/docker-compose/
    docker run --network "container:${container}" appropriate/curl -s -k -o /dev/null -w "%{http_code}" "${endpoint}" | grep "${status_code}"
  else
    curl -s -k -o /dev/null -w "%{http_code}" "${endpoint}" | grep "${status_code}"
  fi
}

function pull_image {
  set -ex
  trap finish EXIT
  docker pull "${image}"
}

function start_docker_compose {
  set -ex
  trap finish EXIT
  # [[ -z "$1" ]] && fatal "Container name not set"
  local compose_file="${1:-${BATS_TEST_DIRNAME}/../docker-compose.yml}"
  local endpoint="${2:-http://localhost:80}"
  local container="${3:-$(get_container_name)}"

  # Wait 30s, retry every .1s
  local -i loop=30
  local interval=0.1

  docker-compose --no-ansi -f "${compose_file}" up -d

  until curl_check_status_code ${endpoint} ${container} 200
  do
    sleep $interval
    loop=$((loop-1))
    if [[ $loop -lt 1 ]]
    then
      docker-compose --no-ansi -f "$compose_file" stop
      >&2 echo "Timeout without successful connection to ${endpoint}"
      >&2 docker-compose --no-ansi -f "$compose_file" logs
      exit 1
    fi
  done
}

function clean_container {
  set -ex
  trap finish EXIT
  [[ -z "$1" ]] && fatal "Container name not set"
  docker stop $1
}

function clean_docker_compose {
  set -ex
  trap finish EXIT
  local compose_file="${1:-${BATS_TEST_DIRNAME}/../docker-compose.yml}"
  docker-compose --no-ansi -f "${compose_file}" stop
  yes | docker-compose --no-ansi -f "${compose_file}" rm
}

function run_test_image_exists {
  set -ex
  trap finish EXIT
  [[ -z "$1" ]] && fatal "Expected response regex not set"
  local image_regex="$1"
  docker images | grep "${image_regex}"
}

function run_test_container_starts {
  set -ex
  trap finish EXIT
  [[ -z "$1" ]] && fatal "No container name specified"
  [[ -z "$2" ]] && fatal "No image specified"
  local name=$1
  local image=$2
  docker run --rm -d --name "$name" "$image"
}
